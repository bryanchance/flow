// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/fynca/fynca/api/services/workflows/v1/workflows.proto

package workflows

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WorkflowStatus int32

const (
	WorkflowStatus_PENDING  WorkflowStatus = 0
	WorkflowStatus_WAITING  WorkflowStatus = 1
	WorkflowStatus_RUNNING  WorkflowStatus = 2
	WorkflowStatus_ERROR    WorkflowStatus = 3
	WorkflowStatus_COMPLETE WorkflowStatus = 4
)

var WorkflowStatus_name = map[int32]string{
	0: "PENDING",
	1: "WAITING",
	2: "RUNNING",
	3: "ERROR",
	4: "COMPLETE",
}

var WorkflowStatus_value = map[string]int32{
	"PENDING":  0,
	"WAITING":  1,
	"RUNNING":  2,
	"ERROR":    3,
	"COMPLETE": 4,
}

func (x WorkflowStatus) String() string {
	return proto.EnumName(WorkflowStatus_name, int32(x))
}

func (WorkflowStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{0}
}

type WorkflowPriority int32

const (
	WorkflowPriority_NORMAL WorkflowPriority = 0
	WorkflowPriority_LOW    WorkflowPriority = 1
	WorkflowPriority_URGENT WorkflowPriority = 2
)

var WorkflowPriority_name = map[int32]string{
	0: "NORMAL",
	1: "LOW",
	2: "URGENT",
}

var WorkflowPriority_value = map[string]int32{
	"NORMAL": 0,
	"LOW":    1,
	"URGENT": 2,
}

func (x WorkflowPriority) String() string {
	return proto.EnumName(WorkflowPriority_name, int32(x))
}

func (WorkflowPriority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{1}
}

type ListWorkflowsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListWorkflowsRequest) Reset()         { *m = ListWorkflowsRequest{} }
func (m *ListWorkflowsRequest) String() string { return proto.CompactTextString(m) }
func (*ListWorkflowsRequest) ProtoMessage()    {}
func (*ListWorkflowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{0}
}
func (m *ListWorkflowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListWorkflowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListWorkflowsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListWorkflowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListWorkflowsRequest.Merge(m, src)
}
func (m *ListWorkflowsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListWorkflowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListWorkflowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListWorkflowsRequest proto.InternalMessageInfo

type WorkflowOutputLink struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Target               string   `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowOutputLink) Reset()         { *m = WorkflowOutputLink{} }
func (m *WorkflowOutputLink) String() string { return proto.CompactTextString(m) }
func (*WorkflowOutputLink) ProtoMessage()    {}
func (*WorkflowOutputLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{1}
}
func (m *WorkflowOutputLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOutputLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOutputLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOutputLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOutputLink.Merge(m, src)
}
func (m *WorkflowOutputLink) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowOutputLink) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOutputLink.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOutputLink proto.InternalMessageInfo

func (m *WorkflowOutputLink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkflowOutputLink) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type WorkflowOutputArtifactUpload struct {
	WorkflowID           string   `protobuf:"bytes,1,opt,name=workfload_id,json=workfloadId,proto3" json:"workfload_id,omitempty"`
	Filename             string   `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
	ContentType          string   `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowOutputArtifactUpload) Reset()         { *m = WorkflowOutputArtifactUpload{} }
func (m *WorkflowOutputArtifactUpload) String() string { return proto.CompactTextString(m) }
func (*WorkflowOutputArtifactUpload) ProtoMessage()    {}
func (*WorkflowOutputArtifactUpload) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{2}
}
func (m *WorkflowOutputArtifactUpload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOutputArtifactUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOutputArtifactUpload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOutputArtifactUpload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOutputArtifactUpload.Merge(m, src)
}
func (m *WorkflowOutputArtifactUpload) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowOutputArtifactUpload) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOutputArtifactUpload.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOutputArtifactUpload proto.InternalMessageInfo

func (m *WorkflowOutputArtifactUpload) GetWorkflowID() string {
	if m != nil {
		return m.WorkflowID
	}
	return ""
}

func (m *WorkflowOutputArtifactUpload) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *WorkflowOutputArtifactUpload) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

type WorkflowOutputArtifact struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ContentType          string   `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	StoragePath          string   `protobuf:"bytes,3,opt,name=storage_path,json=storagePath,proto3" json:"storage_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowOutputArtifact) Reset()         { *m = WorkflowOutputArtifact{} }
func (m *WorkflowOutputArtifact) String() string { return proto.CompactTextString(m) }
func (*WorkflowOutputArtifact) ProtoMessage()    {}
func (*WorkflowOutputArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{3}
}
func (m *WorkflowOutputArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOutputArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOutputArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOutputArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOutputArtifact.Merge(m, src)
}
func (m *WorkflowOutputArtifact) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowOutputArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOutputArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOutputArtifact proto.InternalMessageInfo

func (m *WorkflowOutputArtifact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkflowOutputArtifact) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *WorkflowOutputArtifact) GetStoragePath() string {
	if m != nil {
		return m.StoragePath
	}
	return ""
}

type WorkflowOutputMetadata struct {
	Thumbnail            string                `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Links                []*WorkflowOutputLink `protobuf:"bytes,2,rep,name=links,proto3" json:"links,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *WorkflowOutputMetadata) Reset()         { *m = WorkflowOutputMetadata{} }
func (m *WorkflowOutputMetadata) String() string { return proto.CompactTextString(m) }
func (*WorkflowOutputMetadata) ProtoMessage()    {}
func (*WorkflowOutputMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{4}
}
func (m *WorkflowOutputMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOutputMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOutputMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOutputMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOutputMetadata.Merge(m, src)
}
func (m *WorkflowOutputMetadata) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowOutputMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOutputMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOutputMetadata proto.InternalMessageInfo

func (m *WorkflowOutputMetadata) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

func (m *WorkflowOutputMetadata) GetLinks() []*WorkflowOutputLink {
	if m != nil {
		return m.Links
	}
	return nil
}

type WorkflowOutput struct {
	ID                   string                    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Namespace            string                    `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Metadata             *WorkflowOutputMetadata   `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Log                  string                    `protobuf:"bytes,4,opt,name=log,proto3" json:"log,omitempty"`
	Info                 map[string]string         `protobuf:"bytes,5,rep,name=info,proto3" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Artifacts            []*WorkflowOutputArtifact `protobuf:"bytes,6,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	StartedAt            time.Time                 `protobuf:"bytes,7,opt,name=started_at,json=startedAt,proto3,stdtime" json:"started_at"`
	FinishedAt           time.Time                 `protobuf:"bytes,8,opt,name=finished_at,json=finishedAt,proto3,stdtime" json:"finished_at"`
	Duration             time.Duration             `protobuf:"bytes,9,opt,name=duration,proto3,stdduration" json:"duration"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *WorkflowOutput) Reset()         { *m = WorkflowOutput{} }
func (m *WorkflowOutput) String() string { return proto.CompactTextString(m) }
func (*WorkflowOutput) ProtoMessage()    {}
func (*WorkflowOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{5}
}
func (m *WorkflowOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOutput.Merge(m, src)
}
func (m *WorkflowOutput) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOutput.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOutput proto.InternalMessageInfo

func (m *WorkflowOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *WorkflowOutput) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *WorkflowOutput) GetMetadata() *WorkflowOutputMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowOutput) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

func (m *WorkflowOutput) GetInfo() map[string]string {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *WorkflowOutput) GetArtifacts() []*WorkflowOutputArtifact {
	if m != nil {
		return m.Artifacts
	}
	return nil
}

func (m *WorkflowOutput) GetStartedAt() time.Time {
	if m != nil {
		return m.StartedAt
	}
	return time.Time{}
}

func (m *WorkflowOutput) GetFinishedAt() time.Time {
	if m != nil {
		return m.FinishedAt
	}
	return time.Time{}
}

func (m *WorkflowOutput) GetDuration() time.Duration {
	if m != nil {
		return m.Duration
	}
	return 0
}

type Workflow struct {
	ID                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 string            `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string            `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Parameters           map[string]string `protobuf:"bytes,5,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InputPath            string            `protobuf:"bytes,6,opt,name=input_path,json=inputPath,proto3" json:"input_path,omitempty"`
	Status               WorkflowStatus    `protobuf:"varint,7,opt,name=status,proto3,enum=fynca.services.workflows.v1.WorkflowStatus" json:"status,omitempty"`
	Output               *WorkflowOutput   `protobuf:"bytes,8,opt,name=output,proto3" json:"output,omitempty"`
	CreatedAt            time.Time         `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt            time.Time         `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
	SequenceID           uint64            `protobuf:"varint,11,opt,name=sequence_id,json=sequenceId,proto3" json:"sequence_id,omitempty"`
	Priority             WorkflowPriority  `protobuf:"varint,12,opt,name=priority,proto3,enum=fynca.services.workflows.v1.WorkflowPriority" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{6}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.Size()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

func (m *Workflow) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Workflow) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Workflow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Workflow) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Workflow) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Workflow) GetInputPath() string {
	if m != nil {
		return m.InputPath
	}
	return ""
}

func (m *Workflow) GetStatus() WorkflowStatus {
	if m != nil {
		return m.Status
	}
	return WorkflowStatus_PENDING
}

func (m *Workflow) GetOutput() *WorkflowOutput {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *Workflow) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Workflow) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *Workflow) GetSequenceID() uint64 {
	if m != nil {
		return m.SequenceID
	}
	return 0
}

func (m *Workflow) GetPriority() WorkflowPriority {
	if m != nil {
		return m.Priority
	}
	return WorkflowPriority_NORMAL
}

type ListWorkflowsResponse struct {
	Workflows            []*Workflow `protobuf:"bytes,1,rep,name=workflows,proto3" json:"workflows,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListWorkflowsResponse) Reset()         { *m = ListWorkflowsResponse{} }
func (m *ListWorkflowsResponse) String() string { return proto.CompactTextString(m) }
func (*ListWorkflowsResponse) ProtoMessage()    {}
func (*ListWorkflowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{7}
}
func (m *ListWorkflowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListWorkflowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListWorkflowsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListWorkflowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListWorkflowsResponse.Merge(m, src)
}
func (m *ListWorkflowsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListWorkflowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListWorkflowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListWorkflowsResponse proto.InternalMessageInfo

func (m *ListWorkflowsResponse) GetWorkflows() []*Workflow {
	if m != nil {
		return m.Workflows
	}
	return nil
}

type GetWorkflowRequest struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWorkflowRequest) Reset()         { *m = GetWorkflowRequest{} }
func (m *GetWorkflowRequest) String() string { return proto.CompactTextString(m) }
func (*GetWorkflowRequest) ProtoMessage()    {}
func (*GetWorkflowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{8}
}
func (m *GetWorkflowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWorkflowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWorkflowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWorkflowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWorkflowRequest.Merge(m, src)
}
func (m *GetWorkflowRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWorkflowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWorkflowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWorkflowRequest proto.InternalMessageInfo

func (m *GetWorkflowRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type GetWorkflowResponse struct {
	Workflow             *Workflow `protobuf:"bytes,1,opt,name=workflow,proto3" json:"workflow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetWorkflowResponse) Reset()         { *m = GetWorkflowResponse{} }
func (m *GetWorkflowResponse) String() string { return proto.CompactTextString(m) }
func (*GetWorkflowResponse) ProtoMessage()    {}
func (*GetWorkflowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{9}
}
func (m *GetWorkflowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWorkflowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWorkflowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWorkflowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWorkflowResponse.Merge(m, src)
}
func (m *GetWorkflowResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWorkflowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWorkflowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWorkflowResponse proto.InternalMessageInfo

func (m *GetWorkflowResponse) GetWorkflow() *Workflow {
	if m != nil {
		return m.Workflow
	}
	return nil
}

type WorkflowInputFile struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	ContentType          string   `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowInputFile) Reset()         { *m = WorkflowInputFile{} }
func (m *WorkflowInputFile) String() string { return proto.CompactTextString(m) }
func (*WorkflowInputFile) ProtoMessage()    {}
func (*WorkflowInputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{10}
}
func (m *WorkflowInputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInputFile.Merge(m, src)
}
func (m *WorkflowInputFile) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInputFile.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInputFile proto.InternalMessageInfo

func (m *WorkflowInputFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *WorkflowInputFile) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

type WorkflowInputWorkflows struct {
	IDs                  []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowInputWorkflows) Reset()         { *m = WorkflowInputWorkflows{} }
func (m *WorkflowInputWorkflows) String() string { return proto.CompactTextString(m) }
func (*WorkflowInputWorkflows) ProtoMessage()    {}
func (*WorkflowInputWorkflows) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{11}
}
func (m *WorkflowInputWorkflows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInputWorkflows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInputWorkflows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInputWorkflows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInputWorkflows.Merge(m, src)
}
func (m *WorkflowInputWorkflows) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInputWorkflows) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInputWorkflows.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInputWorkflows proto.InternalMessageInfo

func (m *WorkflowInputWorkflows) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

type WorkflowRequest struct {
	Type       string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Name       string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Parameters map[string]string `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Priority   WorkflowPriority  `protobuf:"varint,4,opt,name=priority,proto3,enum=fynca.services.workflows.v1.WorkflowPriority" json:"priority,omitempty"`
	// Types that are valid to be assigned to Input:
	//	*WorkflowRequest_Workflows
	//	*WorkflowRequest_File
	Input                isWorkflowRequest_Input `protobuf_oneof:"input"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *WorkflowRequest) Reset()         { *m = WorkflowRequest{} }
func (m *WorkflowRequest) String() string { return proto.CompactTextString(m) }
func (*WorkflowRequest) ProtoMessage()    {}
func (*WorkflowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{12}
}
func (m *WorkflowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowRequest.Merge(m, src)
}
func (m *WorkflowRequest) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowRequest proto.InternalMessageInfo

type isWorkflowRequest_Input interface {
	isWorkflowRequest_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WorkflowRequest_Workflows struct {
	Workflows *WorkflowInputWorkflows `protobuf:"bytes,5,opt,name=workflows,proto3,oneof" json:"workflows,omitempty"`
}
type WorkflowRequest_File struct {
	File *WorkflowInputFile `protobuf:"bytes,6,opt,name=file,proto3,oneof" json:"file,omitempty"`
}

func (*WorkflowRequest_Workflows) isWorkflowRequest_Input() {}
func (*WorkflowRequest_File) isWorkflowRequest_Input()      {}

func (m *WorkflowRequest) GetInput() isWorkflowRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *WorkflowRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *WorkflowRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkflowRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *WorkflowRequest) GetPriority() WorkflowPriority {
	if m != nil {
		return m.Priority
	}
	return WorkflowPriority_NORMAL
}

func (m *WorkflowRequest) GetWorkflows() *WorkflowInputWorkflows {
	if x, ok := m.GetInput().(*WorkflowRequest_Workflows); ok {
		return x.Workflows
	}
	return nil
}

func (m *WorkflowRequest) GetFile() *WorkflowInputFile {
	if x, ok := m.GetInput().(*WorkflowRequest_File); ok {
		return x.File
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WorkflowRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WorkflowRequest_Workflows)(nil),
		(*WorkflowRequest_File)(nil),
	}
}

type QueueWorkflowRequest struct {
	// Types that are valid to be assigned to Data:
	//	*QueueWorkflowRequest_Request
	//	*QueueWorkflowRequest_ChunkData
	Data                 isQueueWorkflowRequest_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *QueueWorkflowRequest) Reset()         { *m = QueueWorkflowRequest{} }
func (m *QueueWorkflowRequest) String() string { return proto.CompactTextString(m) }
func (*QueueWorkflowRequest) ProtoMessage()    {}
func (*QueueWorkflowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{13}
}
func (m *QueueWorkflowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueWorkflowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueWorkflowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueWorkflowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueWorkflowRequest.Merge(m, src)
}
func (m *QueueWorkflowRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueWorkflowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueWorkflowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueWorkflowRequest proto.InternalMessageInfo

type isQueueWorkflowRequest_Data interface {
	isQueueWorkflowRequest_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueueWorkflowRequest_Request struct {
	Request *WorkflowRequest `protobuf:"bytes,1,opt,name=request,proto3,oneof" json:"request,omitempty"`
}
type QueueWorkflowRequest_ChunkData struct {
	ChunkData []byte `protobuf:"bytes,2,opt,name=chunk_data,json=chunkData,proto3,oneof" json:"chunk_data,omitempty"`
}

func (*QueueWorkflowRequest_Request) isQueueWorkflowRequest_Data()   {}
func (*QueueWorkflowRequest_ChunkData) isQueueWorkflowRequest_Data() {}

func (m *QueueWorkflowRequest) GetData() isQueueWorkflowRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QueueWorkflowRequest) GetRequest() *WorkflowRequest {
	if x, ok := m.GetData().(*QueueWorkflowRequest_Request); ok {
		return x.Request
	}
	return nil
}

func (m *QueueWorkflowRequest) GetChunkData() []byte {
	if x, ok := m.GetData().(*QueueWorkflowRequest_ChunkData); ok {
		return x.ChunkData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueueWorkflowRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueueWorkflowRequest_Request)(nil),
		(*QueueWorkflowRequest_ChunkData)(nil),
	}
}

type QueueWorkflowResponse struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueWorkflowResponse) Reset()         { *m = QueueWorkflowResponse{} }
func (m *QueueWorkflowResponse) String() string { return proto.CompactTextString(m) }
func (*QueueWorkflowResponse) ProtoMessage()    {}
func (*QueueWorkflowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{14}
}
func (m *QueueWorkflowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueWorkflowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueWorkflowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueWorkflowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueWorkflowResponse.Merge(m, src)
}
func (m *QueueWorkflowResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueWorkflowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueWorkflowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueWorkflowResponse proto.InternalMessageInfo

func (m *QueueWorkflowResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type DeleteWorkflowRequest struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWorkflowRequest) Reset()         { *m = DeleteWorkflowRequest{} }
func (m *DeleteWorkflowRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWorkflowRequest) ProtoMessage()    {}
func (*DeleteWorkflowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{15}
}
func (m *DeleteWorkflowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWorkflowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteWorkflowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteWorkflowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWorkflowRequest.Merge(m, src)
}
func (m *DeleteWorkflowRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWorkflowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWorkflowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWorkflowRequest proto.InternalMessageInfo

func (m *DeleteWorkflowRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type SubscriberInfo struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	MaxWorkflows         uint64   `protobuf:"varint,3,opt,name=max_workflows,json=maxWorkflows,proto3" json:"max_workflows,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriberInfo) Reset()         { *m = SubscriberInfo{} }
func (m *SubscriberInfo) String() string { return proto.CompactTextString(m) }
func (*SubscriberInfo) ProtoMessage()    {}
func (*SubscriberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{16}
}
func (m *SubscriberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriberInfo.Merge(m, src)
}
func (m *SubscriberInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubscriberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriberInfo proto.InternalMessageInfo

func (m *SubscriberInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *SubscriberInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SubscriberInfo) GetMaxWorkflows() uint64 {
	if m != nil {
		return m.MaxWorkflows
	}
	return 0
}

type SubscribeWorkflowEventsRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SubscribeWorkflowEventsRequest_Info
	//	*SubscribeWorkflowEventsRequest_Output
	//	*SubscribeWorkflowEventsRequest_Close
	Request              isSubscribeWorkflowEventsRequest_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *SubscribeWorkflowEventsRequest) Reset()         { *m = SubscribeWorkflowEventsRequest{} }
func (m *SubscribeWorkflowEventsRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeWorkflowEventsRequest) ProtoMessage()    {}
func (*SubscribeWorkflowEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{17}
}
func (m *SubscribeWorkflowEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeWorkflowEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeWorkflowEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeWorkflowEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeWorkflowEventsRequest.Merge(m, src)
}
func (m *SubscribeWorkflowEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeWorkflowEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeWorkflowEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeWorkflowEventsRequest proto.InternalMessageInfo

type isSubscribeWorkflowEventsRequest_Request interface {
	isSubscribeWorkflowEventsRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SubscribeWorkflowEventsRequest_Info struct {
	Info *SubscriberInfo `protobuf:"bytes,1,opt,name=info,proto3,oneof" json:"info,omitempty"`
}
type SubscribeWorkflowEventsRequest_Output struct {
	Output *WorkflowOutput `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type SubscribeWorkflowEventsRequest_Close struct {
	Close bool `protobuf:"varint,3,opt,name=close,proto3,oneof" json:"close,omitempty"`
}

func (*SubscribeWorkflowEventsRequest_Info) isSubscribeWorkflowEventsRequest_Request()   {}
func (*SubscribeWorkflowEventsRequest_Output) isSubscribeWorkflowEventsRequest_Request() {}
func (*SubscribeWorkflowEventsRequest_Close) isSubscribeWorkflowEventsRequest_Request()  {}

func (m *SubscribeWorkflowEventsRequest) GetRequest() isSubscribeWorkflowEventsRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SubscribeWorkflowEventsRequest) GetInfo() *SubscriberInfo {
	if x, ok := m.GetRequest().(*SubscribeWorkflowEventsRequest_Info); ok {
		return x.Info
	}
	return nil
}

func (m *SubscribeWorkflowEventsRequest) GetOutput() *WorkflowOutput {
	if x, ok := m.GetRequest().(*SubscribeWorkflowEventsRequest_Output); ok {
		return x.Output
	}
	return nil
}

func (m *SubscribeWorkflowEventsRequest) GetClose() bool {
	if x, ok := m.GetRequest().(*SubscribeWorkflowEventsRequest_Close); ok {
		return x.Close
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeWorkflowEventsRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeWorkflowEventsRequest_Info)(nil),
		(*SubscribeWorkflowEventsRequest_Output)(nil),
		(*SubscribeWorkflowEventsRequest_Close)(nil),
	}
}

type WorkflowEvent struct {
	// Types that are valid to be assigned to Event:
	//	*WorkflowEvent_Workflow
	//	*WorkflowEvent_Close
	Event                isWorkflowEvent_Event `protobuf_oneof:"event"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *WorkflowEvent) Reset()         { *m = WorkflowEvent{} }
func (m *WorkflowEvent) String() string { return proto.CompactTextString(m) }
func (*WorkflowEvent) ProtoMessage()    {}
func (*WorkflowEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{18}
}
func (m *WorkflowEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowEvent.Merge(m, src)
}
func (m *WorkflowEvent) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowEvent.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowEvent proto.InternalMessageInfo

type isWorkflowEvent_Event interface {
	isWorkflowEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WorkflowEvent_Workflow struct {
	Workflow *Workflow `protobuf:"bytes,1,opt,name=workflow,proto3,oneof" json:"workflow,omitempty"`
}
type WorkflowEvent_Close struct {
	Close bool `protobuf:"varint,2,opt,name=close,proto3,oneof" json:"close,omitempty"`
}

func (*WorkflowEvent_Workflow) isWorkflowEvent_Event() {}
func (*WorkflowEvent_Close) isWorkflowEvent_Event()    {}

func (m *WorkflowEvent) GetEvent() isWorkflowEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *WorkflowEvent) GetWorkflow() *Workflow {
	if x, ok := m.GetEvent().(*WorkflowEvent_Workflow); ok {
		return x.Workflow
	}
	return nil
}

func (m *WorkflowEvent) GetClose() bool {
	if x, ok := m.GetEvent().(*WorkflowEvent_Close); ok {
		return x.Close
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WorkflowEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WorkflowEvent_Workflow)(nil),
		(*WorkflowEvent_Close)(nil),
	}
}

type UpdateWorkflowOutputRequest struct {
	WorkflowOutput       *WorkflowOutput `protobuf:"bytes,1,opt,name=workflow_output,json=workflowOutput,proto3" json:"workflow_output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateWorkflowOutputRequest) Reset()         { *m = UpdateWorkflowOutputRequest{} }
func (m *UpdateWorkflowOutputRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateWorkflowOutputRequest) ProtoMessage()    {}
func (*UpdateWorkflowOutputRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{19}
}
func (m *UpdateWorkflowOutputRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWorkflowOutputRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWorkflowOutputRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWorkflowOutputRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWorkflowOutputRequest.Merge(m, src)
}
func (m *UpdateWorkflowOutputRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWorkflowOutputRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWorkflowOutputRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWorkflowOutputRequest proto.InternalMessageInfo

func (m *UpdateWorkflowOutputRequest) GetWorkflowOutput() *WorkflowOutput {
	if m != nil {
		return m.WorkflowOutput
	}
	return nil
}

type UploadWorkflowArtifactRequest struct {
	// Types that are valid to be assigned to Data:
	//	*UploadWorkflowArtifactRequest_Artifact
	//	*UploadWorkflowArtifactRequest_ChunkData
	Data                 isUploadWorkflowArtifactRequest_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *UploadWorkflowArtifactRequest) Reset()         { *m = UploadWorkflowArtifactRequest{} }
func (m *UploadWorkflowArtifactRequest) String() string { return proto.CompactTextString(m) }
func (*UploadWorkflowArtifactRequest) ProtoMessage()    {}
func (*UploadWorkflowArtifactRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{20}
}
func (m *UploadWorkflowArtifactRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadWorkflowArtifactRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadWorkflowArtifactRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadWorkflowArtifactRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadWorkflowArtifactRequest.Merge(m, src)
}
func (m *UploadWorkflowArtifactRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadWorkflowArtifactRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadWorkflowArtifactRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadWorkflowArtifactRequest proto.InternalMessageInfo

type isUploadWorkflowArtifactRequest_Data interface {
	isUploadWorkflowArtifactRequest_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadWorkflowArtifactRequest_Artifact struct {
	Artifact *WorkflowOutputArtifactUpload `protobuf:"bytes,1,opt,name=artifact,proto3,oneof" json:"artifact,omitempty"`
}
type UploadWorkflowArtifactRequest_ChunkData struct {
	ChunkData []byte `protobuf:"bytes,2,opt,name=chunk_data,json=chunkData,proto3,oneof" json:"chunk_data,omitempty"`
}

func (*UploadWorkflowArtifactRequest_Artifact) isUploadWorkflowArtifactRequest_Data()  {}
func (*UploadWorkflowArtifactRequest_ChunkData) isUploadWorkflowArtifactRequest_Data() {}

func (m *UploadWorkflowArtifactRequest) GetData() isUploadWorkflowArtifactRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadWorkflowArtifactRequest) GetArtifact() *WorkflowOutputArtifactUpload {
	if x, ok := m.GetData().(*UploadWorkflowArtifactRequest_Artifact); ok {
		return x.Artifact
	}
	return nil
}

func (m *UploadWorkflowArtifactRequest) GetChunkData() []byte {
	if x, ok := m.GetData().(*UploadWorkflowArtifactRequest_ChunkData); ok {
		return x.ChunkData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadWorkflowArtifactRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadWorkflowArtifactRequest_Artifact)(nil),
		(*UploadWorkflowArtifactRequest_ChunkData)(nil),
	}
}

type UploadWorkflowArtifactResponse struct {
	StoragePath          string   `protobuf:"bytes,1,opt,name=storage_path,json=storagePath,proto3" json:"storage_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadWorkflowArtifactResponse) Reset()         { *m = UploadWorkflowArtifactResponse{} }
func (m *UploadWorkflowArtifactResponse) String() string { return proto.CompactTextString(m) }
func (*UploadWorkflowArtifactResponse) ProtoMessage()    {}
func (*UploadWorkflowArtifactResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{21}
}
func (m *UploadWorkflowArtifactResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadWorkflowArtifactResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadWorkflowArtifactResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadWorkflowArtifactResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadWorkflowArtifactResponse.Merge(m, src)
}
func (m *UploadWorkflowArtifactResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadWorkflowArtifactResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadWorkflowArtifactResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadWorkflowArtifactResponse proto.InternalMessageInfo

func (m *UploadWorkflowArtifactResponse) GetStoragePath() string {
	if m != nil {
		return m.StoragePath
	}
	return ""
}

type UpdateWorkflowStatusRequest struct {
	ID                   string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Status               WorkflowStatus `protobuf:"varint,2,opt,name=status,proto3,enum=fynca.services.workflows.v1.WorkflowStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateWorkflowStatusRequest) Reset()         { *m = UpdateWorkflowStatusRequest{} }
func (m *UpdateWorkflowStatusRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateWorkflowStatusRequest) ProtoMessage()    {}
func (*UpdateWorkflowStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ee13b57b522a98, []int{22}
}
func (m *UpdateWorkflowStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWorkflowStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWorkflowStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWorkflowStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWorkflowStatusRequest.Merge(m, src)
}
func (m *UpdateWorkflowStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWorkflowStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWorkflowStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWorkflowStatusRequest proto.InternalMessageInfo

func (m *UpdateWorkflowStatusRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *UpdateWorkflowStatusRequest) GetStatus() WorkflowStatus {
	if m != nil {
		return m.Status
	}
	return WorkflowStatus_PENDING
}

func init() {
	proto.RegisterEnum("fynca.services.workflows.v1.WorkflowStatus", WorkflowStatus_name, WorkflowStatus_value)
	proto.RegisterEnum("fynca.services.workflows.v1.WorkflowPriority", WorkflowPriority_name, WorkflowPriority_value)
	proto.RegisterType((*ListWorkflowsRequest)(nil), "fynca.services.workflows.v1.ListWorkflowsRequest")
	proto.RegisterType((*WorkflowOutputLink)(nil), "fynca.services.workflows.v1.WorkflowOutputLink")
	proto.RegisterType((*WorkflowOutputArtifactUpload)(nil), "fynca.services.workflows.v1.WorkflowOutputArtifactUpload")
	proto.RegisterType((*WorkflowOutputArtifact)(nil), "fynca.services.workflows.v1.WorkflowOutputArtifact")
	proto.RegisterType((*WorkflowOutputMetadata)(nil), "fynca.services.workflows.v1.WorkflowOutputMetadata")
	proto.RegisterType((*WorkflowOutput)(nil), "fynca.services.workflows.v1.WorkflowOutput")
	proto.RegisterMapType((map[string]string)(nil), "fynca.services.workflows.v1.WorkflowOutput.InfoEntry")
	proto.RegisterType((*Workflow)(nil), "fynca.services.workflows.v1.Workflow")
	proto.RegisterMapType((map[string]string)(nil), "fynca.services.workflows.v1.Workflow.ParametersEntry")
	proto.RegisterType((*ListWorkflowsResponse)(nil), "fynca.services.workflows.v1.ListWorkflowsResponse")
	proto.RegisterType((*GetWorkflowRequest)(nil), "fynca.services.workflows.v1.GetWorkflowRequest")
	proto.RegisterType((*GetWorkflowResponse)(nil), "fynca.services.workflows.v1.GetWorkflowResponse")
	proto.RegisterType((*WorkflowInputFile)(nil), "fynca.services.workflows.v1.WorkflowInputFile")
	proto.RegisterType((*WorkflowInputWorkflows)(nil), "fynca.services.workflows.v1.WorkflowInputWorkflows")
	proto.RegisterType((*WorkflowRequest)(nil), "fynca.services.workflows.v1.WorkflowRequest")
	proto.RegisterMapType((map[string]string)(nil), "fynca.services.workflows.v1.WorkflowRequest.ParametersEntry")
	proto.RegisterType((*QueueWorkflowRequest)(nil), "fynca.services.workflows.v1.QueueWorkflowRequest")
	proto.RegisterType((*QueueWorkflowResponse)(nil), "fynca.services.workflows.v1.QueueWorkflowResponse")
	proto.RegisterType((*DeleteWorkflowRequest)(nil), "fynca.services.workflows.v1.DeleteWorkflowRequest")
	proto.RegisterType((*SubscriberInfo)(nil), "fynca.services.workflows.v1.SubscriberInfo")
	proto.RegisterType((*SubscribeWorkflowEventsRequest)(nil), "fynca.services.workflows.v1.SubscribeWorkflowEventsRequest")
	proto.RegisterType((*WorkflowEvent)(nil), "fynca.services.workflows.v1.WorkflowEvent")
	proto.RegisterType((*UpdateWorkflowOutputRequest)(nil), "fynca.services.workflows.v1.UpdateWorkflowOutputRequest")
	proto.RegisterType((*UploadWorkflowArtifactRequest)(nil), "fynca.services.workflows.v1.UploadWorkflowArtifactRequest")
	proto.RegisterType((*UploadWorkflowArtifactResponse)(nil), "fynca.services.workflows.v1.UploadWorkflowArtifactResponse")
	proto.RegisterType((*UpdateWorkflowStatusRequest)(nil), "fynca.services.workflows.v1.UpdateWorkflowStatusRequest")
}

func init() {
	proto.RegisterFile("github.com/fynca/fynca/api/services/workflows/v1/workflows.proto", fileDescriptor_30ee13b57b522a98)
}

var fileDescriptor_30ee13b57b522a98 = []byte{
	// 1520 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x16, 0xf5, 0xaf, 0x23, 0xdb, 0xd1, 0x9d, 0xeb, 0xf8, 0x2a, 0x4a, 0x62, 0xe7, 0xb2, 0x28,
	0x60, 0x24, 0xa9, 0x14, 0xdb, 0x28, 0x9a, 0x26, 0x2d, 0x1a, 0xd9, 0x52, 0x23, 0x01, 0x8e, 0xed,
	0xd0, 0x36, 0x1c, 0x14, 0x01, 0x84, 0xb1, 0x34, 0x92, 0x08, 0x4b, 0x24, 0x4b, 0x0e, 0x9d, 0xa8,
	0x40, 0xb7, 0x05, 0xba, 0x0b, 0xd0, 0x4d, 0xb7, 0x7d, 0x80, 0xbe, 0x43, 0x37, 0x05, 0xb2, 0x09,
	0xd0, 0x27, 0x70, 0x0b, 0x3f, 0x49, 0x31, 0xc3, 0x21, 0x25, 0x52, 0x3f, 0x16, 0x9d, 0x8d, 0xc0,
	0x39, 0x33, 0xe7, 0x3b, 0x67, 0xce, 0xff, 0x08, 0x9e, 0x75, 0x54, 0xda, 0xb5, 0x4f, 0x8b, 0x4d,
	0xbd, 0x5f, 0x6a, 0x0f, 0xb4, 0x26, 0x16, 0xbf, 0xd8, 0x50, 0x4b, 0x16, 0x31, 0xcf, 0xd5, 0x26,
	0xb1, 0x4a, 0x6f, 0x74, 0xf3, 0xac, 0xdd, 0xd3, 0xdf, 0x58, 0xa5, 0xf3, 0x8d, 0xe1, 0xa2, 0x68,
	0x98, 0x3a, 0xd5, 0xd1, 0x6d, 0xce, 0x50, 0x74, 0x0f, 0x17, 0x87, 0xfb, 0xe7, 0x1b, 0x85, 0xe5,
	0x8e, 0xde, 0xd1, 0xf9, 0xb9, 0x12, 0xfb, 0x72, 0x58, 0x0a, 0xab, 0x1d, 0x5d, 0xef, 0xf4, 0x48,
	0x89, 0xaf, 0x4e, 0xed, 0x76, 0xa9, 0x65, 0x9b, 0x98, 0xaa, 0xba, 0x26, 0xf6, 0xd7, 0x82, 0xfb,
	0x54, 0xed, 0x13, 0x8b, 0xe2, 0xbe, 0x21, 0x0e, 0xdc, 0x0e, 0x1e, 0x20, 0x7d, 0x83, 0x0e, 0x9c,
	0x4d, 0x79, 0x05, 0x96, 0x77, 0x55, 0x8b, 0x9e, 0xb8, 0x7a, 0x28, 0xe4, 0x7b, 0x9b, 0x58, 0x54,
	0x7e, 0x06, 0xc8, 0xa5, 0xed, 0xdb, 0xd4, 0xb0, 0xe9, 0xae, 0xaa, 0x9d, 0x21, 0x04, 0x71, 0x0d,
	0xf7, 0x49, 0x5e, 0xba, 0x27, 0xad, 0x67, 0x14, 0xfe, 0x8d, 0x56, 0x20, 0x49, 0xb1, 0xd9, 0x21,
	0x34, 0x1f, 0xe5, 0x54, 0xb1, 0x92, 0xdf, 0x49, 0x70, 0xc7, 0x0f, 0x51, 0x36, 0xa9, 0xda, 0xc6,
	0x4d, 0x7a, 0x6c, 0xf4, 0x74, 0xdc, 0x42, 0x1b, 0xb0, 0x20, 0xae, 0x8f, 0x5b, 0x0d, 0xb5, 0xe5,
	0x80, 0x6e, 0x2f, 0x5d, 0x5e, 0xac, 0x81, 0xcb, 0x57, 0xaf, 0x28, 0x59, 0xef, 0x4c, 0xbd, 0x85,
	0x0a, 0x90, 0x6e, 0xab, 0x3d, 0xc2, 0x75, 0x70, 0xa4, 0x79, 0x6b, 0xf4, 0x7f, 0x58, 0x68, 0xea,
	0x1a, 0x25, 0x1a, 0x6d, 0xd0, 0x81, 0x41, 0xf2, 0x31, 0xbe, 0x9f, 0x15, 0xb4, 0xa3, 0x81, 0x41,
	0x64, 0x13, 0x56, 0x26, 0x6b, 0x34, 0xf1, 0x62, 0x41, 0xc0, 0xe8, 0x18, 0x20, 0x3b, 0x62, 0x51,
	0xdd, 0xc4, 0x1d, 0xd2, 0x30, 0x30, 0xed, 0xba, 0x32, 0x05, 0xed, 0x00, 0xd3, 0xae, 0xfc, 0x63,
	0x50, 0xe6, 0x0b, 0x42, 0x71, 0x0b, 0x53, 0x8c, 0xee, 0x40, 0x86, 0x76, 0xed, 0xfe, 0xa9, 0x86,
	0xd5, 0x9e, 0x10, 0x3c, 0x24, 0xa0, 0x2a, 0x24, 0x7a, 0xaa, 0x76, 0x66, 0xe5, 0xa3, 0xf7, 0x62,
	0xeb, 0xd9, 0xcd, 0x52, 0x71, 0x46, 0xe4, 0x14, 0xc7, 0x5d, 0xa5, 0x38, 0xdc, 0xf2, 0x87, 0x38,
	0x2c, 0xf9, 0x77, 0xd1, 0x0a, 0x44, 0x3d, 0x6b, 0x27, 0x2f, 0x2f, 0xd6, 0xa2, 0xf5, 0x8a, 0x12,
	0x55, 0x5b, 0x4c, 0x1f, 0x76, 0x6f, 0xcb, 0xc0, 0x4d, 0xf7, 0xb2, 0x43, 0x02, 0xda, 0x87, 0x74,
	0x5f, 0x68, 0xce, 0xaf, 0x99, 0xdd, 0xdc, 0x0a, 0xa1, 0x92, 0x7b, 0x69, 0xc5, 0x03, 0x41, 0x39,
	0x88, 0xf5, 0xf4, 0x4e, 0x3e, 0xce, 0x05, 0xb1, 0x4f, 0x54, 0x87, 0xb8, 0xaa, 0xb5, 0xf5, 0x7c,
	0x82, 0xdf, 0xf8, 0xf3, 0x10, 0xf0, 0xc5, 0xba, 0xd6, 0xd6, 0xab, 0x1a, 0x35, 0x07, 0x0a, 0x87,
	0x40, 0x2f, 0x21, 0x83, 0x85, 0x6f, 0xad, 0x7c, 0x92, 0xe3, 0x85, 0x51, 0xd7, 0x8d, 0x0b, 0x65,
	0x88, 0x82, 0x76, 0x00, 0x2c, 0x8a, 0x4d, 0x4a, 0x5a, 0x0d, 0x4c, 0xf3, 0x29, 0x6e, 0x82, 0x42,
	0xd1, 0xc9, 0xad, 0xa2, 0x9b, 0x5b, 0xc5, 0x23, 0x37, 0xf9, 0xb6, 0xd3, 0xef, 0x2f, 0xd6, 0x22,
	0xef, 0xfe, 0x5e, 0x93, 0x94, 0x8c, 0xe0, 0x2b, 0x53, 0x54, 0x85, 0x6c, 0x5b, 0xd5, 0x54, 0xab,
	0xeb, 0xa0, 0xa4, 0x43, 0xa0, 0x80, 0xcb, 0x58, 0xa6, 0xe8, 0x1b, 0x48, 0xbb, 0x55, 0x20, 0x9f,
	0xe1, 0x18, 0xb7, 0xc6, 0x30, 0x2a, 0xe2, 0x80, 0x03, 0xf1, 0x2b, 0x83, 0xf0, 0x98, 0x0a, 0x5f,
	0x40, 0xc6, 0x33, 0x19, 0xf3, 0xc4, 0x19, 0x19, 0x88, 0x10, 0x64, 0x9f, 0x68, 0x19, 0x12, 0xe7,
	0xb8, 0x67, 0xbb, 0x61, 0xe0, 0x2c, 0x9e, 0x44, 0x1f, 0x4b, 0xf2, 0xef, 0x09, 0x48, 0xbb, 0xb6,
	0x9a, 0x1a, 0x49, 0x08, 0xe2, 0x23, 0x19, 0xc3, 0xbf, 0xbd, 0x0c, 0x8b, 0x8d, 0x64, 0x98, 0x2f,
	0xe2, 0xe2, 0xc1, 0x88, 0x3b, 0x06, 0x30, 0xb0, 0x89, 0xfb, 0x84, 0x12, 0xd3, 0x0a, 0x15, 0x14,
	0xc5, 0x03, 0x8f, 0xcf, 0x09, 0x8a, 0x11, 0x20, 0x74, 0x17, 0x40, 0xd5, 0x0c, 0x9b, 0x3a, 0x19,
	0x9b, 0x74, 0xa4, 0x72, 0x0a, 0xcb, 0x57, 0xb4, 0x03, 0x49, 0x8b, 0x62, 0x6a, 0x5b, 0xdc, 0xc5,
	0x4b, 0x9b, 0x0f, 0xe6, 0x92, 0x78, 0xc8, 0x59, 0x14, 0xc1, 0xca, 0x40, 0x74, 0x1e, 0x48, 0xc2,
	0xc3, 0x0f, 0x42, 0xc4, 0x9e, 0x22, 0x58, 0x59, 0xc0, 0x35, 0x4d, 0x82, 0x45, 0xc0, 0x65, 0xc2,
	0x04, 0x9c, 0xe0, 0x2b, 0x73, 0x10, 0xdb, 0x68, 0xb9, 0x20, 0x10, 0x06, 0x44, 0xf0, 0x95, 0x29,
	0x2a, 0x41, 0xd6, 0x62, 0x7d, 0x41, 0x6b, 0x12, 0x56, 0xa8, 0xb3, 0xf7, 0xa4, 0xf5, 0xb8, 0x53,
	0xa8, 0x0f, 0x05, 0xb9, 0x5e, 0x51, 0xc0, 0x3d, 0x52, 0x6f, 0xa1, 0x3a, 0xa4, 0x0d, 0x53, 0xd5,
	0x4d, 0x95, 0x0e, 0xf2, 0x0b, 0xdc, 0x8c, 0x9f, 0xcd, 0x65, 0x81, 0x03, 0xc1, 0xa4, 0x78, 0xec,
	0x85, 0xaf, 0xe1, 0x46, 0xc0, 0x9b, 0xa1, 0xe2, 0xf5, 0x35, 0xdc, 0x0c, 0xf4, 0x37, 0xcb, 0xd0,
	0x35, 0x8b, 0xa0, 0x1d, 0xc8, 0x78, 0x2a, 0xe4, 0x25, 0x1e, 0x5c, 0x9f, 0xce, 0xa5, 0xa3, 0x32,
	0xe4, 0x93, 0x1f, 0x02, 0x7a, 0x4e, 0x3c, 0x70, 0xd1, 0x3b, 0xa7, 0xa5, 0x85, 0xfc, 0x0a, 0xfe,
	0xeb, 0x3b, 0x2d, 0x34, 0x29, 0x43, 0xda, 0x45, 0xe4, 0x4c, 0x73, 0x2b, 0xe2, 0xb1, 0xc9, 0x0a,
	0xfc, 0xc7, 0x6b, 0x99, 0x2c, 0x92, 0xbf, 0x55, 0x7b, 0xc4, 0xd7, 0x2c, 0xa5, 0x2b, 0x9a, 0xe5,
	0x78, 0x6f, 0x93, 0xb7, 0x86, 0x8d, 0x8b, 0x63, 0x7a, 0x26, 0x44, 0xb7, 0x20, 0xa6, 0xb6, 0x1c,
	0xa3, 0x65, 0xb6, 0x53, 0x97, 0x17, 0x6b, 0xb1, 0x7a, 0xc5, 0x52, 0x18, 0x4d, 0xfe, 0x33, 0x06,
	0x37, 0x82, 0xe6, 0x70, 0xab, 0x81, 0x34, 0xa1, 0x1a, 0x44, 0x47, 0xaa, 0xc1, 0x6b, 0x5f, 0xbe,
	0xc7, 0xb8, 0x4b, 0xbe, 0x9a, 0xcf, 0x12, 0x8e, 0xa4, 0x99, 0x69, 0x3f, 0x1a, 0x92, 0xf1, 0x8f,
	0x0a, 0x49, 0x74, 0x38, 0x1a, 0x3a, 0x89, 0x10, 0xbd, 0xd0, 0x6f, 0xc7, 0x5a, 0x64, 0x24, 0x94,
	0x50, 0x05, 0xe2, 0xcc, 0x3b, 0xbc, 0x20, 0x65, 0x37, 0x8b, 0xf3, 0xe3, 0x31, 0x5f, 0xd7, 0x22,
	0x0a, 0xe7, 0xfe, 0xc8, 0x6c, 0xd9, 0x4e, 0x41, 0x82, 0x57, 0x42, 0xf9, 0x67, 0x09, 0x96, 0x5f,
	0xda, 0xc4, 0x26, 0x41, 0x67, 0xd6, 0x20, 0x65, 0x3a, 0x9f, 0x22, 0x56, 0x1f, 0x86, 0xf1, 0x50,
	0x2d, 0xa2, 0xb8, 0xec, 0x68, 0x0d, 0xa0, 0xd9, 0xb5, 0xb5, 0xb3, 0x06, 0x1f, 0x29, 0x98, 0x2a,
	0x0b, 0xcc, 0x22, 0x9c, 0x56, 0xc1, 0x14, 0x6f, 0x27, 0x21, 0xce, 0xb6, 0xe4, 0x12, 0xdc, 0x0c,
	0xa8, 0x22, 0x12, 0x67, 0x5a, 0x9e, 0x95, 0xe0, 0x66, 0x85, 0xf4, 0x08, 0x25, 0xf3, 0x26, 0x26,
	0x86, 0xa5, 0x43, 0xfb, 0xd4, 0x6a, 0x9a, 0xea, 0x29, 0x31, 0x59, 0x5f, 0x0c, 0xd5, 0xd9, 0x3e,
	0x81, 0xc5, 0x3e, 0x7e, 0xdb, 0x18, 0x86, 0x04, 0x6b, 0x71, 0x71, 0x65, 0xa1, 0x8f, 0xdf, 0x7a,
	0xbe, 0x96, 0x3f, 0x48, 0xb0, 0xea, 0xc9, 0x70, 0xc9, 0xd5, 0x73, 0xa2, 0x51, 0x77, 0xe4, 0x46,
	0x65, 0x31, 0xfe, 0x48, 0x73, 0xb4, 0x0c, 0xbf, 0xba, 0xcc, 0xfd, 0x7c, 0xec, 0xa9, 0x7a, 0x7d,
	0x27, 0x1a, 0xba, 0xef, 0xd4, 0x22, 0x5e, 0xe7, 0x59, 0x81, 0x44, 0xb3, 0xa7, 0x5b, 0x4e, 0xb3,
	0x4e, 0xd7, 0x22, 0x8a, 0xb3, 0xdc, 0xce, 0x78, 0xce, 0x97, 0x6d, 0x58, 0xf4, 0xdd, 0x02, 0xed,
	0x5c, 0xb3, 0x8a, 0xd5, 0x22, 0xc3, 0x3a, 0x36, 0x14, 0x1c, 0xf5, 0x0b, 0x4e, 0x41, 0x82, 0x30,
	0x29, 0xb2, 0x05, 0xb7, 0x8f, 0x79, 0x5b, 0x0a, 0xf4, 0x4c, 0x61, 0xc2, 0x23, 0xb8, 0xe1, 0x62,
	0x35, 0x84, 0x21, 0xa4, 0xf0, 0x0d, 0x78, 0xe9, 0x8d, 0x6f, 0x2d, 0xff, 0x26, 0xc1, 0x5d, 0xe7,
	0xcd, 0xe2, 0x1e, 0xf4, 0xe6, 0x43, 0x21, 0xf7, 0x04, 0xd2, 0xee, 0xa0, 0x28, 0x04, 0x7e, 0x79,
	0x8d, 0x69, 0xd3, 0x91, 0xc1, 0x0c, 0xe2, 0x82, 0xcd, 0x9f, 0x24, 0x3b, 0xb0, 0x3a, 0x4d, 0x45,
	0x91, 0x2d, 0xc1, 0xb7, 0x8a, 0x34, 0xfe, 0x56, 0xf9, 0x21, 0x68, 0x5d, 0x31, 0xd6, 0xcc, 0x4e,
	0x9f, 0x91, 0x91, 0x29, 0x7a, 0xed, 0x91, 0xe9, 0xfe, 0xc1, 0xf0, 0x9d, 0xe2, 0xec, 0xa0, 0x2c,
	0xa4, 0x0e, 0xaa, 0x7b, 0x95, 0xfa, 0xde, 0xf3, 0x5c, 0x84, 0x2d, 0x4e, 0xca, 0xf5, 0x23, 0xb6,
	0x90, 0xd8, 0x42, 0x39, 0xde, 0xdb, 0x63, 0x8b, 0x28, 0xca, 0x40, 0xa2, 0xaa, 0x28, 0xfb, 0x4a,
	0x2e, 0x86, 0x16, 0x20, 0xbd, 0xb3, 0xff, 0xe2, 0x60, 0xb7, 0x7a, 0x54, 0xcd, 0xc5, 0xef, 0x6f,
	0x41, 0x2e, 0x58, 0xc4, 0x11, 0x40, 0x72, 0x6f, 0x5f, 0x79, 0x51, 0xde, 0xcd, 0x45, 0x50, 0x0a,
	0x62, 0xbb, 0xfb, 0x27, 0x39, 0x89, 0x11, 0x8f, 0x95, 0xe7, 0xd5, 0xbd, 0xa3, 0x5c, 0x74, 0xf3,
	0x8f, 0x14, 0x64, 0x86, 0x9d, 0xee, 0x2d, 0x2c, 0xfa, 0x4a, 0x0f, 0xda, 0x98, 0x79, 0xb5, 0x49,
	0x15, 0xb3, 0xb0, 0x19, 0x86, 0xc5, 0xf1, 0xd5, 0xba, 0x84, 0xce, 0x61, 0xd1, 0x37, 0xb7, 0x5c,
	0x21, 0x79, 0xd2, 0x1b, 0xfe, 0x0a, 0xc9, 0x93, 0xc7, 0x22, 0x03, 0xb2, 0x23, 0x33, 0x0a, 0x9a,
	0xfd, 0xec, 0x1c, 0x9f, 0x7d, 0x0a, 0x8f, 0xe6, 0x67, 0x10, 0x12, 0x5f, 0xc3, 0x92, 0xbf, 0x5a,
	0xa3, 0xd9, 0x7a, 0x4f, 0x2c, 0xed, 0x85, 0x95, 0xb1, 0x99, 0xb6, 0xda, 0x37, 0xe8, 0x00, 0xfd,
	0x24, 0xc1, 0xff, 0xa6, 0xd4, 0x5d, 0xf4, 0x74, 0xbe, 0x12, 0x3b, 0xb1, 0x5a, 0x17, 0xee, 0xcf,
	0x15, 0xe4, 0x9c, 0x67, 0x5d, 0x7a, 0x24, 0xa1, 0x5f, 0x24, 0x58, 0x99, 0x9c, 0xa1, 0xe8, 0xc9,
	0x4c, 0xa8, 0x99, 0x95, 0xa7, 0xf0, 0xf4, 0x5a, 0xbc, 0x5e, 0x98, 0x75, 0x61, 0x79, 0x52, 0xc6,
	0xa3, 0xc7, 0x57, 0xc0, 0x4e, 0x2d, 0x12, 0x53, 0x1d, 0x31, 0x26, 0x49, 0xfc, 0x1b, 0x11, 0x46,
	0x92, 0xaf, 0xd8, 0x4f, 0x93, 0xb4, 0x5d, 0x7b, 0x7f, 0xb9, 0x2a, 0xfd, 0x75, 0xb9, 0x2a, 0xfd,
	0x73, 0xb9, 0x2a, 0x7d, 0xf7, 0x24, 0xec, 0x7f, 0x76, 0x4f, 0xbd, 0xc5, 0xab, 0xd8, 0x69, 0x92,
	0x63, 0x6f, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x0a, 0xe9, 0xc4, 0xd2, 0xfa, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WorkflowsClient is the client API for Workflows service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkflowsClient interface {
	QueueWorkflow(ctx context.Context, opts ...grpc.CallOption) (Workflows_QueueWorkflowClient, error)
	ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error)
	GetWorkflow(ctx context.Context, in *GetWorkflowRequest, opts ...grpc.CallOption) (*GetWorkflowResponse, error)
	DeleteWorkflow(ctx context.Context, in *DeleteWorkflowRequest, opts ...grpc.CallOption) (*types.Empty, error)
	SubscribeWorkflowEvents(ctx context.Context, opts ...grpc.CallOption) (Workflows_SubscribeWorkflowEventsClient, error)
	UploadWorkflowArtifact(ctx context.Context, opts ...grpc.CallOption) (Workflows_UploadWorkflowArtifactClient, error)
	UpdateWorkflowStatus(ctx context.Context, in *UpdateWorkflowStatusRequest, opts ...grpc.CallOption) (*types.Empty, error)
	UpdateWorkflowOutput(ctx context.Context, in *UpdateWorkflowOutputRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type workflowsClient struct {
	cc *grpc.ClientConn
}

func NewWorkflowsClient(cc *grpc.ClientConn) WorkflowsClient {
	return &workflowsClient{cc}
}

func (c *workflowsClient) QueueWorkflow(ctx context.Context, opts ...grpc.CallOption) (Workflows_QueueWorkflowClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Workflows_serviceDesc.Streams[0], "/fynca.services.workflows.v1.Workflows/QueueWorkflow", opts...)
	if err != nil {
		return nil, err
	}
	x := &workflowsQueueWorkflowClient{stream}
	return x, nil
}

type Workflows_QueueWorkflowClient interface {
	Send(*QueueWorkflowRequest) error
	CloseAndRecv() (*QueueWorkflowResponse, error)
	grpc.ClientStream
}

type workflowsQueueWorkflowClient struct {
	grpc.ClientStream
}

func (x *workflowsQueueWorkflowClient) Send(m *QueueWorkflowRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workflowsQueueWorkflowClient) CloseAndRecv() (*QueueWorkflowResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(QueueWorkflowResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workflowsClient) ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error) {
	out := new(ListWorkflowsResponse)
	err := c.cc.Invoke(ctx, "/fynca.services.workflows.v1.Workflows/ListWorkflows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowsClient) GetWorkflow(ctx context.Context, in *GetWorkflowRequest, opts ...grpc.CallOption) (*GetWorkflowResponse, error) {
	out := new(GetWorkflowResponse)
	err := c.cc.Invoke(ctx, "/fynca.services.workflows.v1.Workflows/GetWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowsClient) DeleteWorkflow(ctx context.Context, in *DeleteWorkflowRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/fynca.services.workflows.v1.Workflows/DeleteWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowsClient) SubscribeWorkflowEvents(ctx context.Context, opts ...grpc.CallOption) (Workflows_SubscribeWorkflowEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Workflows_serviceDesc.Streams[1], "/fynca.services.workflows.v1.Workflows/SubscribeWorkflowEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &workflowsSubscribeWorkflowEventsClient{stream}
	return x, nil
}

type Workflows_SubscribeWorkflowEventsClient interface {
	Send(*SubscribeWorkflowEventsRequest) error
	Recv() (*WorkflowEvent, error)
	grpc.ClientStream
}

type workflowsSubscribeWorkflowEventsClient struct {
	grpc.ClientStream
}

func (x *workflowsSubscribeWorkflowEventsClient) Send(m *SubscribeWorkflowEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workflowsSubscribeWorkflowEventsClient) Recv() (*WorkflowEvent, error) {
	m := new(WorkflowEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workflowsClient) UploadWorkflowArtifact(ctx context.Context, opts ...grpc.CallOption) (Workflows_UploadWorkflowArtifactClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Workflows_serviceDesc.Streams[2], "/fynca.services.workflows.v1.Workflows/UploadWorkflowArtifact", opts...)
	if err != nil {
		return nil, err
	}
	x := &workflowsUploadWorkflowArtifactClient{stream}
	return x, nil
}

type Workflows_UploadWorkflowArtifactClient interface {
	Send(*UploadWorkflowArtifactRequest) error
	CloseAndRecv() (*UploadWorkflowArtifactResponse, error)
	grpc.ClientStream
}

type workflowsUploadWorkflowArtifactClient struct {
	grpc.ClientStream
}

func (x *workflowsUploadWorkflowArtifactClient) Send(m *UploadWorkflowArtifactRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workflowsUploadWorkflowArtifactClient) CloseAndRecv() (*UploadWorkflowArtifactResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadWorkflowArtifactResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workflowsClient) UpdateWorkflowStatus(ctx context.Context, in *UpdateWorkflowStatusRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/fynca.services.workflows.v1.Workflows/UpdateWorkflowStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowsClient) UpdateWorkflowOutput(ctx context.Context, in *UpdateWorkflowOutputRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/fynca.services.workflows.v1.Workflows/UpdateWorkflowOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowsServer is the server API for Workflows service.
type WorkflowsServer interface {
	QueueWorkflow(Workflows_QueueWorkflowServer) error
	ListWorkflows(context.Context, *ListWorkflowsRequest) (*ListWorkflowsResponse, error)
	GetWorkflow(context.Context, *GetWorkflowRequest) (*GetWorkflowResponse, error)
	DeleteWorkflow(context.Context, *DeleteWorkflowRequest) (*types.Empty, error)
	SubscribeWorkflowEvents(Workflows_SubscribeWorkflowEventsServer) error
	UploadWorkflowArtifact(Workflows_UploadWorkflowArtifactServer) error
	UpdateWorkflowStatus(context.Context, *UpdateWorkflowStatusRequest) (*types.Empty, error)
	UpdateWorkflowOutput(context.Context, *UpdateWorkflowOutputRequest) (*types.Empty, error)
}

// UnimplementedWorkflowsServer can be embedded to have forward compatible implementations.
type UnimplementedWorkflowsServer struct {
}

func (*UnimplementedWorkflowsServer) QueueWorkflow(srv Workflows_QueueWorkflowServer) error {
	return status.Errorf(codes.Unimplemented, "method QueueWorkflow not implemented")
}
func (*UnimplementedWorkflowsServer) ListWorkflows(ctx context.Context, req *ListWorkflowsRequest) (*ListWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflows not implemented")
}
func (*UnimplementedWorkflowsServer) GetWorkflow(ctx context.Context, req *GetWorkflowRequest) (*GetWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflow not implemented")
}
func (*UnimplementedWorkflowsServer) DeleteWorkflow(ctx context.Context, req *DeleteWorkflowRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflow not implemented")
}
func (*UnimplementedWorkflowsServer) SubscribeWorkflowEvents(srv Workflows_SubscribeWorkflowEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeWorkflowEvents not implemented")
}
func (*UnimplementedWorkflowsServer) UploadWorkflowArtifact(srv Workflows_UploadWorkflowArtifactServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadWorkflowArtifact not implemented")
}
func (*UnimplementedWorkflowsServer) UpdateWorkflowStatus(ctx context.Context, req *UpdateWorkflowStatusRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowStatus not implemented")
}
func (*UnimplementedWorkflowsServer) UpdateWorkflowOutput(ctx context.Context, req *UpdateWorkflowOutputRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowOutput not implemented")
}

func RegisterWorkflowsServer(s *grpc.Server, srv WorkflowsServer) {
	s.RegisterService(&_Workflows_serviceDesc, srv)
}

func _Workflows_QueueWorkflow_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkflowsServer).QueueWorkflow(&workflowsQueueWorkflowServer{stream})
}

type Workflows_QueueWorkflowServer interface {
	SendAndClose(*QueueWorkflowResponse) error
	Recv() (*QueueWorkflowRequest, error)
	grpc.ServerStream
}

type workflowsQueueWorkflowServer struct {
	grpc.ServerStream
}

func (x *workflowsQueueWorkflowServer) SendAndClose(m *QueueWorkflowResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workflowsQueueWorkflowServer) Recv() (*QueueWorkflowRequest, error) {
	m := new(QueueWorkflowRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Workflows_ListWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowsServer).ListWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fynca.services.workflows.v1.Workflows/ListWorkflows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowsServer).ListWorkflows(ctx, req.(*ListWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workflows_GetWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowsServer).GetWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fynca.services.workflows.v1.Workflows/GetWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowsServer).GetWorkflow(ctx, req.(*GetWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workflows_DeleteWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowsServer).DeleteWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fynca.services.workflows.v1.Workflows/DeleteWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowsServer).DeleteWorkflow(ctx, req.(*DeleteWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workflows_SubscribeWorkflowEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkflowsServer).SubscribeWorkflowEvents(&workflowsSubscribeWorkflowEventsServer{stream})
}

type Workflows_SubscribeWorkflowEventsServer interface {
	Send(*WorkflowEvent) error
	Recv() (*SubscribeWorkflowEventsRequest, error)
	grpc.ServerStream
}

type workflowsSubscribeWorkflowEventsServer struct {
	grpc.ServerStream
}

func (x *workflowsSubscribeWorkflowEventsServer) Send(m *WorkflowEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workflowsSubscribeWorkflowEventsServer) Recv() (*SubscribeWorkflowEventsRequest, error) {
	m := new(SubscribeWorkflowEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Workflows_UploadWorkflowArtifact_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkflowsServer).UploadWorkflowArtifact(&workflowsUploadWorkflowArtifactServer{stream})
}

type Workflows_UploadWorkflowArtifactServer interface {
	SendAndClose(*UploadWorkflowArtifactResponse) error
	Recv() (*UploadWorkflowArtifactRequest, error)
	grpc.ServerStream
}

type workflowsUploadWorkflowArtifactServer struct {
	grpc.ServerStream
}

func (x *workflowsUploadWorkflowArtifactServer) SendAndClose(m *UploadWorkflowArtifactResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workflowsUploadWorkflowArtifactServer) Recv() (*UploadWorkflowArtifactRequest, error) {
	m := new(UploadWorkflowArtifactRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Workflows_UpdateWorkflowStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowsServer).UpdateWorkflowStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fynca.services.workflows.v1.Workflows/UpdateWorkflowStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowsServer).UpdateWorkflowStatus(ctx, req.(*UpdateWorkflowStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workflows_UpdateWorkflowOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowsServer).UpdateWorkflowOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fynca.services.workflows.v1.Workflows/UpdateWorkflowOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowsServer).UpdateWorkflowOutput(ctx, req.(*UpdateWorkflowOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Workflows_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fynca.services.workflows.v1.Workflows",
	HandlerType: (*WorkflowsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListWorkflows",
			Handler:    _Workflows_ListWorkflows_Handler,
		},
		{
			MethodName: "GetWorkflow",
			Handler:    _Workflows_GetWorkflow_Handler,
		},
		{
			MethodName: "DeleteWorkflow",
			Handler:    _Workflows_DeleteWorkflow_Handler,
		},
		{
			MethodName: "UpdateWorkflowStatus",
			Handler:    _Workflows_UpdateWorkflowStatus_Handler,
		},
		{
			MethodName: "UpdateWorkflowOutput",
			Handler:    _Workflows_UpdateWorkflowOutput_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueueWorkflow",
			Handler:       _Workflows_QueueWorkflow_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeWorkflowEvents",
			Handler:       _Workflows_SubscribeWorkflowEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadWorkflowArtifact",
			Handler:       _Workflows_UploadWorkflowArtifact_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/fynca/fynca/api/services/workflows/v1/workflows.proto",
}

func (m *ListWorkflowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListWorkflowsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListWorkflowsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOutputLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOutputLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOutputLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOutputArtifactUpload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOutputArtifactUpload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOutputArtifactUpload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkflowID) > 0 {
		i -= len(m.WorkflowID)
		copy(dAtA[i:], m.WorkflowID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.WorkflowID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOutputArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOutputArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOutputArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StoragePath) > 0 {
		i -= len(m.StoragePath)
		copy(dAtA[i:], m.StoragePath)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.StoragePath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOutputMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOutputMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOutputMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorkflows(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Duration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintWorkflows(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x4a
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.FinishedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.FinishedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintWorkflows(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x42
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.StartedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.StartedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintWorkflows(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x3a
	if len(m.Artifacts) > 0 {
		for iNdEx := len(m.Artifacts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifacts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorkflows(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Info) > 0 {
		for k := range m.Info {
			v := m.Info[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWorkflows(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x22
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Priority != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x60
	}
	if m.SequenceID != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x58
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintWorkflows(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x52
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintWorkflows(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x4a
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.InputPath) > 0 {
		i -= len(m.InputPath)
		copy(dAtA[i:], m.InputPath)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.InputPath)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWorkflows(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListWorkflowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListWorkflowsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListWorkflowsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Workflows) > 0 {
		for iNdEx := len(m.Workflows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Workflows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorkflows(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetWorkflowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWorkflowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWorkflowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWorkflowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWorkflowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWorkflowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Workflow != nil {
		{
			size, err := m.Workflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInputFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInputFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInputWorkflows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInputWorkflows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInputWorkflows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IDs) > 0 {
		for iNdEx := len(m.IDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IDs[iNdEx])
			copy(dAtA[i:], m.IDs[iNdEx])
			i = encodeVarintWorkflows(dAtA, i, uint64(len(m.IDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWorkflows(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWorkflows(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowRequest_Workflows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowRequest_Workflows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Workflows != nil {
		{
			size, err := m.Workflows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *WorkflowRequest_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowRequest_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *QueueWorkflowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueWorkflowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueWorkflowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueueWorkflowRequest_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueWorkflowRequest_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *QueueWorkflowRequest_ChunkData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueWorkflowRequest_ChunkData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChunkData != nil {
		i -= len(m.ChunkData)
		copy(dAtA[i:], m.ChunkData)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ChunkData)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QueueWorkflowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueWorkflowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueWorkflowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWorkflowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWorkflowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWorkflowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriberInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriberInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxWorkflows != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.MaxWorkflows))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeWorkflowEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeWorkflowEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeWorkflowEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeWorkflowEventsRequest_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeWorkflowEventsRequest_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeWorkflowEventsRequest_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeWorkflowEventsRequest_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeWorkflowEventsRequest_Close) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeWorkflowEventsRequest_Close) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Close {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *WorkflowEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowEvent_Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEvent_Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Workflow != nil {
		{
			size, err := m.Workflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WorkflowEvent_Close) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEvent_Close) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Close {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *UpdateWorkflowOutputRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWorkflowOutputRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWorkflowOutputRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WorkflowOutput != nil {
		{
			size, err := m.WorkflowOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadWorkflowArtifactRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadWorkflowArtifactRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadWorkflowArtifactRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UploadWorkflowArtifactRequest_Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadWorkflowArtifactRequest_Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Artifact != nil {
		{
			size, err := m.Artifact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorkflows(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UploadWorkflowArtifactRequest_ChunkData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadWorkflowArtifactRequest_ChunkData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChunkData != nil {
		i -= len(m.ChunkData)
		copy(dAtA[i:], m.ChunkData)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ChunkData)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UploadWorkflowArtifactResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadWorkflowArtifactResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadWorkflowArtifactResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StoragePath) > 0 {
		i -= len(m.StoragePath)
		copy(dAtA[i:], m.StoragePath)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.StoragePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateWorkflowStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWorkflowStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWorkflowStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintWorkflows(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintWorkflows(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintWorkflows(dAtA []byte, offset int, v uint64) int {
	offset -= sovWorkflows(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListWorkflowsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowOutputLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowOutputArtifactUpload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkflowID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowOutputArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.StoragePath)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowOutputMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovWorkflows(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWorkflows(uint64(len(k))) + 1 + len(v) + sovWorkflows(uint64(len(v)))
			n += mapEntrySize + 1 + sovWorkflows(uint64(mapEntrySize))
		}
	}
	if len(m.Artifacts) > 0 {
		for _, e := range m.Artifacts {
			l = e.Size()
			n += 1 + l + sovWorkflows(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.StartedAt)
	n += 1 + l + sovWorkflows(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.FinishedAt)
	n += 1 + l + sovWorkflows(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration)
	n += 1 + l + sovWorkflows(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWorkflows(uint64(len(k))) + 1 + len(v) + sovWorkflows(uint64(len(v)))
			n += mapEntrySize + 1 + sovWorkflows(uint64(mapEntrySize))
		}
	}
	l = len(m.InputPath)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovWorkflows(uint64(m.Status))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovWorkflows(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovWorkflows(uint64(l))
	if m.SequenceID != 0 {
		n += 1 + sovWorkflows(uint64(m.SequenceID))
	}
	if m.Priority != 0 {
		n += 1 + sovWorkflows(uint64(m.Priority))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListWorkflowsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Workflows) > 0 {
		for _, e := range m.Workflows {
			l = e.Size()
			n += 1 + l + sovWorkflows(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWorkflowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWorkflowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workflow != nil {
		l = m.Workflow.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowInputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowInputWorkflows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, s := range m.IDs {
			l = len(s)
			n += 1 + l + sovWorkflows(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWorkflows(uint64(len(k))) + 1 + len(v) + sovWorkflows(uint64(len(v)))
			n += mapEntrySize + 1 + sovWorkflows(uint64(mapEntrySize))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovWorkflows(uint64(m.Priority))
	}
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowRequest_Workflows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workflows != nil {
		l = m.Workflows.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *WorkflowRequest_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *QueueWorkflowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueWorkflowRequest_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *QueueWorkflowRequest_ChunkData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkData != nil {
		l = len(m.ChunkData)
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *QueueWorkflowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWorkflowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriberInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.MaxWorkflows != 0 {
		n += 1 + sovWorkflows(uint64(m.MaxWorkflows))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeWorkflowEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeWorkflowEventsRequest_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *SubscribeWorkflowEventsRequest_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *SubscribeWorkflowEventsRequest_Close) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *WorkflowEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowEvent_Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workflow != nil {
		l = m.Workflow.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *WorkflowEvent_Close) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *UpdateWorkflowOutputRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowOutput != nil {
		l = m.WorkflowOutput.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadWorkflowArtifactRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadWorkflowArtifactRequest_Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Artifact != nil {
		l = m.Artifact.Size()
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *UploadWorkflowArtifactRequest_ChunkData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkData != nil {
		l = len(m.ChunkData)
		n += 1 + l + sovWorkflows(uint64(l))
	}
	return n
}
func (m *UploadWorkflowArtifactResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoragePath)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateWorkflowStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovWorkflows(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovWorkflows(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWorkflows(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWorkflows(x uint64) (n int) {
	return sovWorkflows(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListWorkflowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListWorkflowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListWorkflowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOutputLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOutputLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOutputLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOutputArtifactUpload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOutputArtifactUpload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOutputArtifactUpload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkflowID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOutputArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOutputArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOutputArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOutputMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOutputMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOutputMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &WorkflowOutputLink{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &WorkflowOutputMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorkflows
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWorkflows(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWorkflows
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = append(m.Artifacts, &WorkflowOutputArtifact{})
			if err := m.Artifacts[len(m.Artifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.FinishedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorkflows
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWorkflows(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWorkflows
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= WorkflowStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &WorkflowOutput{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= WorkflowPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListWorkflowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListWorkflowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListWorkflowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workflows = append(m.Workflows, &Workflow{})
			if err := m.Workflows[len(m.Workflows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWorkflowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWorkflowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWorkflowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWorkflowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWorkflowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWorkflowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Workflow == nil {
				m.Workflow = &Workflow{}
			}
			if err := m.Workflow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInputWorkflows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInputWorkflows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInputWorkflows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorkflows
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorkflows
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthWorkflows
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWorkflows(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWorkflows
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= WorkflowPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkflowInputWorkflows{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WorkflowRequest_Workflows{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkflowInputFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WorkflowRequest_File{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueWorkflowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueWorkflowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueWorkflowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkflowRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &QueueWorkflowRequest_Request{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Data = &QueueWorkflowRequest_ChunkData{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueWorkflowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueWorkflowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueWorkflowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWorkflowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWorkflowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWorkflowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWorkflows", wireType)
			}
			m.MaxWorkflows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWorkflows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeWorkflowEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeWorkflowEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeWorkflowEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubscriberInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SubscribeWorkflowEventsRequest_Info{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkflowOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SubscribeWorkflowEventsRequest_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Request = &SubscribeWorkflowEventsRequest_Close{b}
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Workflow{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &WorkflowEvent_Workflow{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Event = &WorkflowEvent_Close{b}
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWorkflowOutputRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWorkflowOutputRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWorkflowOutputRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowOutput == nil {
				m.WorkflowOutput = &WorkflowOutput{}
			}
			if err := m.WorkflowOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadWorkflowArtifactRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadWorkflowArtifactRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadWorkflowArtifactRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkflowOutputArtifactUpload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &UploadWorkflowArtifactRequest_Artifact{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Data = &UploadWorkflowArtifactRequest_ChunkData{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadWorkflowArtifactResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadWorkflowArtifactResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadWorkflowArtifactResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWorkflowStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWorkflowStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWorkflowStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkflows
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorkflows
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= WorkflowStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorkflows(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorkflows
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWorkflows(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWorkflows
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorkflows
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWorkflows
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWorkflows
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWorkflows
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWorkflows        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWorkflows          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWorkflows = fmt.Errorf("proto: unexpected end of group")
)
